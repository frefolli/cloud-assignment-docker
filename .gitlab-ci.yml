# The image used for this CI/CD Action should contain a JDK 17 (used by brew-day) and maven as well
# We chose a Debian Bookwork containing the AmazonCorretto redistribution of JDK 17
# Having to rely on Debian instead of Ubuntu enable us to have update yet stable toolkits.
#
# It's really important to notice how we don't need to impose dependency on NodeJS but only against Maven.
# This because our setup allow the `frontend/pom.xml` to download a distribution of node by it self.
image: maven:3.9.4-amazoncorretto-17-debian-bookworm

# Configure CI/CD to run on master Branch updates, but only when a PR is not acting on it, and for PR in general.
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Global environment variables that are available within each job container environment
variables:
  # Probably used during dockerization
  DOCKER_HOST: tcp://docker:2375
  DOCKER_DRIVER: overlay2
  #
  # Used in release phase
  CONTAINER_IMAGE: $CI_REGISTRY_IMAGE
  #
  # Since this Action is run inside a cloud Gitlab instance, we need to set constaints on resources and stategies of Maven.
  # We also set a customized location for Maven repository in order to be able to cache it.
  MAVEN_CLI_OPTS: "-C --threads 1C --batch-mode -Dmaven.repo.local=.m2/repository"

# We define one cache that is used by all jobs
# We are allowed to define root-relative paths for targets and so on,
# because `mvn` cli accepts a parameter `-pl` which takes as input the project name.
#
# As you can notice, in the root pom.xml two subprojects are defined
# - 1) frontend
# - 2) backend
#
# Running `mvn compile -pl backend` will trigger the compilation of only backend, which is great
# as it applies to the specified lifecycle (es: test, verify, package ...).
cache:
  - key: "$CI_COMMIT_REF_SLUG"
    paths:
      - frontend/node/         # Local NodeJS installation
      - frontend/node_modules/ # Local NPM repository
      - .m2/repository/        # Local Maven repository
      - backend/target/        # Maven output directory for Backend
      - frontend/build/        # NPM output directory for Frontend

# Stages definition:
#
stages:
  - clean
  - build
  - verify
  - unit-test
  - integration-test
  - package
  - release
  - docs

# CLEAN
# 
# We added a CLEAN stage to ensure that cache is ready for the workflow.
# For example, we set up a check in frontend/pom.xml to ensure that `npm run build` is run only once.
clean-cache:
  stage: clean
  script:
    - mvn $MAVEN_CLI_OPTS clean

# BUILD
# 
# Frontend and Backend can be built using two concurrent jobs.
frontend-build:
  stage: build
  script:
    - mvn $MAVEN_CLI_OPTS compile -pl frontend

backend-build:
  stage: build
  script:
    - mvn $MAVEN_CLI_OPTS compile -pl backend

# VERIFY
#
## BACKEND
## 
## As backend linters we run
## 
## - 1) SpotBugs     https://spotbugs.github.io/
## - 2) CheckStyle   https://checkstyle.sourceforge.io/
## - 3) PMD          https://pmd.github.io/
##
## Since JDK 17 is only officially supported starting with FindSec-Plugin 1.12.0,
##   and that this specific version lacks of fixes to generic type parsing introduced
##   with issue #680, we decided to run SpotBugs without it.
## 
## We also decided to run CheckStyle on the backend part using the default Sun stylechecks
##   provided by the framework for simplicity.
## 
## Finally instead of running Valgrind, which could be useful if running native application,
##   although it was suggested in the Assignment 1 paper, we run additional checks with PMD,
##   another source code analyzer, which "finds common programming flaws like unused variables,
##   empty catch blocks, unnecessary object creation, and so forth".
## 
## The original project ran SonarQube against both Frontend and Backend thanks to the SonarCloud
##   account provided by Ingegneria del Software course. In order to avoid abouse of this priviledge
##   and useless bloats on that account, we decided to skip the usage of this tool.
## 
## Every verification job allows mvn to fail as a trigger for upload of checking frameworks reports.
## We don't feel the need for a distinct cache space for these jobs, so we kept the main one.
## 
backend-spotbugs:
  stage: verify
  script:
    - ls backend/target/classes/unimib/ingsof
    - mvn $MAVEN_CLI_OPTS -pl backend spotbugs:check
  allow_failure: true
  artifacts:
    paths:
      - backend/target/spotbugsXml.xml
    when: on_failure
  dependencies: []
## 
backend-checkstyle:
  stage: verify
  script:
    - mvn $MAVEN_CLI_OPTS -pl backend checkstyle:check
  allow_failure: true
  artifacts:
    paths:
      - backend/target/checkstyle-result.xml
    when: on_failure
  dependencies: []
## 
backend-pmd:
  stage: verify
  script:
    - mvn $MAVEN_CLI_OPTS -pl backend pmd:check
  allow_failure: true
  artifacts:
    paths:
      - backend/target/pmd.xml
    when: on_failure
  dependencies: []
## 
## FRONTEND
## 
## 

# UNIT-TEST

# INTEGRATION-TEST

# PACKAGE

# RELEASE

# DOCS

